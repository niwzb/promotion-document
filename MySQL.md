# 索引
* 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据（主键索引叶子节点保存整行数据）  
非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行（myisam，innodb叶子节点存储的是主键值）
* force index；ignore index

# 主从同步
* Binary log：主数据库的二进制日志
* Relay log：从服务器的中继日志
> 第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。  
第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。  
如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。  
第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。

## MVCC
* MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读
* 当前读  
像 select lock in share mode (共享锁), select for update; update; insert; delete (排他锁)这些操作都是一种当前读，
为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
* 快照读  
像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；
之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC ,可以认为 MVCC 是行锁的一个变种，
但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

* InnoDB的MVCC  
通过在每行记录后面保存两个隐藏的列来实现：一个保存了行的创建时间，一个保存行的过期时间（删除时间），  
当然，这里的时间并不是时间戳，而是系统版本号，每开始一个新的事务，系统版本号就会递增。  
在RR隔离级别下，MVCC的操作如下：  
1、select操作。  
InnoDB只查找版本早于（包含等于）当前事务版本的数据行。可以确保事务读取的行，要么是事务开始前就已存在，或者事务自身插入或修改的记录。  
行的删除版本要么未定义，要么大于当前事务版本号。可以确保事务读取的行，在事务开始之前未删除。  
2、insert操作。  
将新插入的行保存当前版本号为行版本号。  
3、delete操作。  
将删除的行保存当前版本号为删除标识。  
4、update操作。  
变为insert和delete操作的组合，insert的行保存当前版本号为行版本号，delete则保存当前版本号到原来的行作为删除标识。  
由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。

## 数据库并发场景有三种，分别为：  
* 读-读：不存在任何问题，也不需要并发控制  
* 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读  
* 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失
> MVCC + 悲观锁  
  MVCC解决读写冲突，悲观锁解决写写冲突  
  MVCC + 乐观锁  
  MVCC 解决读写冲突，乐观锁解决写写冲突
  
## 隐式字段
> 每行记录除了我们自定义的字段外，还有数据库隐式定义的 DB_TRX_ID, DB_ROLL_PTR, DB_ROW_ID 等字段  
* DB_TRX_ID：6 byte，最近修改(修改/插入)事务 ID：记录创建这条记录/最后一次修改该记录的事务 ID
* DB_ROLL_PTR：7 byte，回滚指针，指向这条记录的上一个版本（存储于 rollback segment 里）
* DB_ROW_ID：6 byte，隐含的自增 ID（隐藏主键），如果数据表没有主键，InnoDB 会自动以DB_ROW_ID产生一个聚簇索引
> 实际还有一个删除 flag 隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除 flag 变了

* update undo log（修改行时将旧数据复制到undo log日志里）

* read view
> repeatable read 同一个read view；read committed 一个事务一个read view

## 锁
* InnoDB是基于索引来完成行锁
* InnoDB存储引擎的锁的算法有三种
> Record lock：单个行记录上的锁  
 Gap lock：间隙锁，锁定一个范围，不包括记录本身  
 Next-key lock：record+gap 锁定一个范围，包含记录本身
 * 相关知识点：  
1：innodb对于行的查询使用next-key lock  
2：Next-locking keying为了解决Phantom Problem幻读问题  
3：当查询的索引含有唯一属性时，将next-key lock降级为record key  
4：Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生  
5：有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

## 资源
* show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。
* 开启慢查询日志
> 开启慢查询日志：slow_query_log；设置临界时间：long_query_time

## 分库分表
* hash取模方案：没有热点问题，但扩容迁移数据痛苦
* range方案：不需要迁移数据，但有热点问题。
> 能否根据服务器的性能以及存储高低，适当均匀调整存储呢？
* group组，组里面包含了一些分库以及分表
> 范围确定组 》 hash取模确定DB（组里表总数） 》 范围确定表  
本地缓存维护关系表：组数据范围表、DB对应取模表、数据范围表

## MySQL的binlog录入格式
> 有三种格式，statement，row和mixed。
* statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
* row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
* mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
* 此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。

## 索引下推
* 索引下推在非主键索引上的优化，可以有效减少回表的次数，大大提升了查询的效率。
  
   
