# promotion-document

# JVM相关
## GC基础
* 新生代GC ygc（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。
* 老年代GC fgc（Major GC/Full GC）:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上
* 大对象直接进入老年代
* 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。
* 为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。
* 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，
* 虚拟机给每个对象一个对象年龄（Age）计数器。
* 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1.
* 对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，
* 可以通过参数 -XX:MaxTenuringThreshold 来设置。
> 内存分配担保机制：当在新生代无法分配内存的时候，把新生代的对象转移到老生代，然后把新对象放入腾空的新生代。parallel scavenge 下判断新分配的对象大小 >= Eden区的一半，则新对象直接进入老年代，否则启用分配担保机制；serial下直接启用分配担保机制。

## 常见垃圾收集器
* 1.Serial（串行）收集器收集器
Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条
垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop The World" ），直到它收集结束
新生代采用复制算法，老年代采用标记-整理算法。

* 2.ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。
新生代采用复制算法，老年代采用标记-整理算法。

* 3.Parallel Scavenge收集器
Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户
代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，
可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。
新生代采用复制算法，老年代采用标记-整理算法。

* 4.CMS收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。  
**初始标记**： 暂停所有的其他线程(STW)，并记录下直接与root相连的对象，速度很快 ；  
**并发标记**： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。  
**重新标记**： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。  
**并发清除**： 开启用户线程，同时GC线程开始对未标记的区域做清扫。  
从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：  
对CPU资源敏感（会和服务抢资源）；  
无法处理浮动垃圾(在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了)；  
它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

* 5.G1收集器
G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.
G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。
这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率。
  
## 内存溢出
jmap -dump:format=b,file=eureka.hprof 13988  
也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)  
-XX:+HeapDumpOnOutOfMemoryError  
-XX:HeapDumpPath=./   （路径）  
用jstack查找死锁，见如下示例，也可以用jvisualvm查看死锁  
jstack找出占用cpu最高的堆栈信息  
1，使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如4977  
2，按H，获取每个线程的内存情况  
3，找到内存和cpu占用最高的线程tid，比如4977  
4，转为十六进制得到 0x1371 ,此为线程id的十六进制表示  
5，执行 jstack 4977|grep -A 10 1371，得到线程堆栈信息中1371这个线程所在行的后面10行  
6，查看对应的堆栈信息找出可能存在问题的代码
  
## 类加载器
启动类加载器：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等  
扩展类加载器：负责加载JRE扩展目录ext中JAR类包（*可以自定义-Djava.ext.dir*）  
系统类加载器：负责加载ClassPath路径下的类包  
用户自定义加载器：负责加载用户自定义路径下的类包  
全盘负责委托机制：当一个ClassLoader加载一个类时，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入  
双亲委派机制：指先委托父类加载器寻找目标类，在找不到的情况下在自己的路径中查找并载入目标类  
双亲委派模式优势  
沙箱安全机制：自己写的String.class类不会被加载，这样便可以防止核心API库被随意篡改  
避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次  
> 反射机制：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。java通常是先有类再有对象，有对象我就可以调用方法或者属性。反射其实是通过Class对象来调用类里面的方法。通过反射可以调用私有方法和私有属性。

## HTTP
TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。  
TIME_WAIT:  
是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接。
CLOSE_WAIT:  
是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。
但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。
此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。  
  
## Cache
> MySQL: query_cache_size= 128M  
         Data Buffer  
         data buffer是数据库数据在内存中的容器  
         data buffer的命中率直接决定了数据库的性能  
         data buffer越大越好，多多益善  
         MySQL的InnoDB buffer：innodb_buffer_pool_size = 2G  
         MySQL建议buffer pool开大到服务器物理内存60-80%  

## Redis
* AOF fsync到磁盘配置策略：1.每条命令执行；2.一秒钟执行；3.交给操作系统。 重启时 check-aof
* RDB save 60 1000 表示在60秒内有1000条命令（更新）则保持一次rdb文件
> 开启混合持久化 aof-use-rdb-preamble yes
* 底层数据结构 (*查看内部存储结构命令 OBJECT ENCODING key*)
> String 有*embstr*和*int*; embstr:simple dynamic string,SDS; List quicklist 双向链表; Hash 字典; zset skiplist 跳跃表; set intset 整数集合
> *压缩列表：将数据按照一定规则编码在一块连续的空间*  

## 基础
* hash冲突解决办法：开放地址法、链地址法、再hash法、建立公共溢出区  
> aqs采用开放地址法 hashmap采用链地址法  
* synchronized锁方法时字节码编译添加 ACC_SYNCHRONIZED  
> 排查死锁可以通过jstack pid来查看栈信息，死锁线程会展示为dead lock；  


