## Linux 上查找哪个线程cpu利用率最高
* top -H -p pid （然后按下shift+p）
* 线程号转换成16进制
* jstack pid > /tmp/t.dat

## 线程调度模型
* 分时调度模型和抢占式调度模型。

## 线程通信
* Java中线程通信协作的最常见的两种方式：  
一.syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()  
二.ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()  
* 线程间直接的数据交换：  
三.通过管道进行线程间通信：1）字节流；2）字符流  

## 线程同步
* 线程间的同步方法大体可分为两类：用户模式和内核模式  
> 用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。  

## 线程池
* 无界队列可继续添加
* 有解队列：任务首先会被添加到队列中，队列满了，会根据最大核心线程数的值增加线程数量，如果增加了线程数量还是处理不过来，队列继续满，那么则会使用拒绝策略RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy

## 重排序与数据依赖性
* 重排序需要满足以下两个条件
> 在单线程环境下不能改变程序运行的结果；  
存在数据依赖关系的不允许重排序

## 对象内存结构
### 对象头
* 第一部分markword,用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、  
偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“MarkWord”。
* 对象头的另外一部分是klass类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例.
* 如果对象是一个数组, 那在对象头中还必须有一块数据用于记录数组长度.
### 实例数据
* 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。
### 对齐填充
* 由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

